#Application Structure
#应用结构


With the decision to change the supported development platform from the ADT bundle to Android Studio also came the decision to start using Gradle as the build system. This opened the door for many developers to start assembling Android applications in a more collaborative way and changed the file structure with which prior projects were built.

当开发环境从ADT bundle转向Android Studio的同时，Gradle开始作为编译系统。这让开发者有了很多协作的方式去开发Android应用，并且改变了编译文件的结构。

In this chapter, you learn the new file system structure as well as the types of files you can
include in your project, including where XML files are located, where image assets are stored,
and where the Gradle build files are stored. 

在本章中，你将会学到新的文件系统结构以及项目中使用到的文件类型，包括XML文件,图片资源,还有Gradle编译文件的存放位置。

When you create an application in Android Studio, you find that the project is divided into an
App folder and Gradle scripts. 

Figure 3.1shows this structure. 

当你在Android Studio中创建应用程序时，你会发现项目分为App文件夹和Gradle脚本文件。

图3.1 所示结构

![图3.1 所示结构](pic_3.2.png)

Figure 3.1   The App folder and the Grade Scripts section are visible in the Project window. 

图3.1  在项目面板中显示的 App文件夹和Gradle 脚本。

The App folder contains three subfolders that house the files and resources that make up your
application. They are divided so that it should be fairly easy to determine which assets go in
which folder; however, those new to application development or those looking to migrate from
the older Eclipse-based development model might not be certain where files should go. To
make this easier, I walk you through each folder and what it contains. 

在App文件夹中有三个子文件夹，用于存放应用程序中的文件和资源。他们是隔离开的，所以很容易确定相关文件在哪个文件夹中，然而，新手或者从Eclipse转移过来的开发者可能不清楚文件该如何存放，为了使这更容易，我将带你逐一到访每个文件夹，去了解它所包含的内容。

##Manifests(清单文件)
The manifests folder lives up to its name. This is where you would put your manifest files.
Depending on your target, you may have only one manifest file, or you may have several. You
may have several manifest files due to application versioning, or even for supporting specific
hardware. 

清单文件夹没有辜负它的名字， 这里放置你的清单文件，根据你的目标，你可能有一个或多个清单文件，你可能因应用版本，或者支持特定的硬件，使用多个清单文件。

A manifest file is generated by Android Studio when you create a project. Listing 3.1shows a
generated manifest file. 

清单文件是由你创建项目的时候被Android Studio生成的， 列表3.1显示了生成的清单文件。

Listing 3.1 Contents of a Generated Manifest File from Android Studio 

列表3.1 从Android Studio 生成的清单文件

```
   <?xml version="1.0" encoding="utf-8"?>
   <manifest xmlns:android="http://schemas.android.com/apk/res/android"
   package="com.dutsonpa.helloandroid" >
   <application
   android:allowBackup="true"
   android:icon="@drawable/ic_launcher"
   android:label="@string/app_name"
   android:theme="@style/AppTheme" >
   <activity
   android:name=".MainActivity"
   android:label="@string/app_name" >
   <intent-filter>
   <action android:name="android.intent.action.MAIN" />
   <category android:name="android.intent.category.LAUNCHER" />
   </intent-filter>
   </activity>
   </application>
   </manifest> 
```

If you have worked with an Android manifest file before, this file should look familiar. It is
an XML file and as such begins with a declaration of <?xml version="1.0" encoding=
"utf-8"?>. This is done so that the application knows how to handle the information
contained within the file. Because it has been declared as an XML file, you will find that
options and settings inside this file consist of elements that may contain attributes. The next
element after the declaration is a prime example. 

如果你之前用到过Android的清单文件，那么你看到这些应该很熟悉，这是一个以 <?xml version="1.0" encoding= “utf-8”?>声明开始的XML文件，这样做是使得应用程序知道如何处理包含在文件中的信息。因为它被声明为一个XML文件，你会发现文件中的选项和设置是由很多包含属性的元素组成的。在声明之后的下一个元素是一个典型的例子。

The <manifest> element contains some attributes: the XML namespace for Android and the
package name for your application. The package name is the one you created when you started
the project. The <manifest> element can also contain child elements.

在 <manifest> 元素中包含一些属性： Android使用的XML命名空间和应用程序的包名称。
包名称是启动项目的时候创建的。在 <manifest> 元素中同样还可以包含子元素。

In Listing 3.1 , there is only one child element: the <application> element. This contains
more attributes that will affect how your application is displayed as well as if the user is allowed
to have the application be backed up. Other child elements may include any Activities, Intents,
Providers, Receivers, Services, and so on, that the application will need to use.

在清单3.1中，只有一个子元素：<application>元素。它包含更多的属性，它将会影响到应用程序的显示，以及是否允许用户对应用程序进行备份。其他子元素包括应用程序使用到的 Activities, Intents, Providers, Receivers, Services等。

Your manifest may also contain other elements, such as the <uses-permission> element. This
element is both the bane and balm of the application developer. By allowing your application
some access to system functionality, you can create applications that appear to be pure magic,
giving users access to everything they want when they want it. This unfortunately can also
cause some very scary messages to be displayed to the user when they install your application.
A user is much more likely to install your application if you ask for only what you absolutely
need in order to accomplish a task rather than requesting the keys to the kingdom and promising
that you won’t compromise the user or their personal data. 

清单文件中还可以包含其他元素，例如 <uses-permission> 。这个元素对应用开发人员来说是把双刃剑。通过允许应用程序访问一些系统功能，你可以很神奇的创建一个用户想要访问任何事情的应用，不幸的是当他们安装应用程序时，在安装页面会显示一些非常可怕的消息。用户更喜欢去安装请求必要权限达到目的的应用，而不是会危害到用户或者个人数据的应用。

>Note

>You may have previously used <compatible-screens> elements to target specific screen
>sizes for your application. This is no longer an encouraged method of creating applications.
>Instead, you should use different layout resources to allow as many users as possible to enjoy
>and use your application. 

注意
你可能在你的应用程序中已经使用过<compatible-screens>元素来给特定的屏幕尺寸使用。这种做法不再被推荐使用。你应该使用不同的布局资源，让尽可能多的用户享受和使用你的应用程序。

Due to the nature of XML, the order in which you add or remove elements does not matter as
much as the child-parent relationship. However, note that the official documentation lists that
the following elements be ordered as shown in the following pseudo-code: 

由于XML的特质，在其中添加或删除元素的时候顺序并不重要，等同于父子关系。但是，请注意，官方文档列表中显示在下面的伪代码是被排好顺序的：


```
 <manifest>
 <uses-permission />
 <permission />
 <permission-tree />
 <permission-group />
 <instrumentation />
 <uses-sdk />
 <uses-configuration />
 <uses-feature />
 <supports-screens />
 <compatible-screens />
 <supports-gl-texture />
 <application>
 <activity>
 <intent-filter>
 <action />
 <category />
 <data />
 </intent-filter>
 <meta-data />
 </activity>
 <activity-alias>
 <intent-filter></intent-filter>
 <meta-data />
 </activity-alias>
 <service>
 <intent-filter></intent-filter>
 <meta-data/>
 </service>
 <receiver>
 <intent-filter></intent-filter>
 <meta-data />
 </receiver>
 <provider>
 <grant-uri-permission />
 <meta-data />
 <path-permission />
 </provider>
 <uses-library />
 </application>
 </manifest> 
 ```
 
You may be tempted to invent and add your own elements; however, you should know that
the manifest is parsed for a specific set of elements and when custom elements are found it will
cause an error. This is also true when using custom attributes inside of elements.

你可能会想创造并添加自己的元素;但是，你应该知道，清单文件是被解析为特定的元素的集合，当出现自定义的元素会导致错误。同样在元素中使用自定义的属性也会引发错误。

##Java
 
The java folder is self-explanatory. This is the folder in your project where you will be storing
all of the Java files you use to create and work with your application.

java文件夹是不言自明。在这里，你将存储所有项目用到的java文件。

All of your classes will be available here, and Android Studio will even bundle together the
package path so that you can work with the files without having to drill down through the
folders that make up your package.

所有的类都将在这里，Android Studio将会把文件和包路径绑定在一起，这样就可以不用在文件夹下面找来找去了。

You are not limited to keeping your classes inside of the package root. Just like when working
with other Java applications, you are free to create subdirectories that make sense and place
your classes inside of them.

你可以不用非把类文件放在根目录，就像开发其他的java应用一样，你可以自由的创建子目录，然后把类文件放在对应的目录中。

For example, if you were working with database connections and wanted all of your data
classes to reside in an easy-to-use storage location, you could create a “data” folder and place
your classes inside. 

例如，如果你在做数据库连接的工作，并希望所有的数据类驻留在一个易于使用存储的位置，你可以创建一个“Data”文件夹，里面放上你的类。

Depending on how you are creating your application, you may be able to import your classes
for use inside of your MainActivity. If I had created a class for database work named MyDB
and placed it in the “data” folder, I would use the following import to use it inside of my
MainActivity :

根据你创建应用程序的方式，你可以在你的MainActivity中导入Java类使用。如果我创建了一个名为MyDB的数据库相关的类文件，并把它放在“data”文件夹中，我将会使用下面的语句导入到我的MainActivity中：

```
 import com.dutsonpa.HelloAndroid.data.MyDB;
```

When working with your own project, you need to change the domain ( dutsonpa) and application
name ( HelloAndroid) to match.
 
当你使用在自己的项目时，你需要更改域（dutson）和应用程序名称（HelloAndroid）为你的项目中所用到的。

##Res (Resources) (资源)

The manifest and java folders have so far held the essential portions of the application that
allow it to be installed and the logical portion of your application. The “res” folder switches
things up a little bit by controlling the layout, media, and constants that will be used in your
application. The folder is thus named due to it containing all of the resources that your app
relies on. It contains folders that help you separate and sort the resources of your application.

清单文件和java文件夹，已经包含了应用程序的配置和应用程序的逻辑部分。 在“res”文件夹中，通过改变里面的内容，控制在应用中用到的布局，媒体和常量等。因此，该文件夹的名字就是因为包含所有你的应用程序依赖的资源。它包含了帮助你对应用程序的资源进行分离和排序的文件夹。

##Drawable(图片)

The drawable folder contains all the visual media and resources that your application will need
to use. Table 3.1shows drawable types that you can place and use inside of this folder.
 
drawable 文件夹中包含所有的应用中用到的视觉媒体和资源。表3.1列出了 你可以放在drawable下使用的图片类型

Table 3.1 Resource Files for Drawable Folder

表3.1  Drawable文件夹下的资源文件

Drawable Resource | File Type
 --- | ---
Bitmap | Images files (such as .jpg, .png, and .gif).
| 图片文件（例如 .jpg, .png, and .gif).

Clip Drawable | An XML file consisting of points that is used in conjunction with
another drawable to create a clipped object.
Insert Drawable | An XML file that is used to place one drawable inside the bounds of
another drawable.
Layer List | An XML file that contains an array made up of other drawables. Note
that items will be drawn in order based on location in the array placing
item [0] on the bottom layer.
Level List | An XML file that is used to display other drawables that can be
accessed based on the level requested through setImageLevel() .
 Nine-Patch | A PNG image file that can stretch specific portions to scale based on
content size. 

 



When you use Android Studio to create a new application, some folders will be automatically
generated for you. However, these folders are not the only ones you can use in your project.
The following are the folders that can be used inside of the res folder. 






