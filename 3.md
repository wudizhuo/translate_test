#Application Structure
#应用结构


With the decision to change the supported development platform from the ADT bundle to Android Studio also came the decision to start using Gradle as the build system. This opened the door for many developers to start assembling Android applications in a more collaborative way and changed the file structure with which prior projects were built.

当开发环境从ADT bundle转向Android Studio的同时，Gradle开始作为编译系统。这让开发者有了很多协作的方式去开发Android应用，并且改变了编译文件的结构。

In this chapter, you learn the new file system structure as well as the types of files you can
include in your project, including where XML files are located, where image assets are stored,
and where the Gradle build files are stored. 

在本章中，你将会学到新的文件系统结构以及项目中使用到的文件类型，包括XML文件,图片资源,还有Gradle编译文件的存放位置。

When you create an application in Android Studio, you find that the project is divided into an
App folder and Gradle scripts. 

Figure 3.1shows this structure. 

当你在Android Studio中创建应用程序时，你会发现项目分为App文件夹和Gradle脚本文件。

图3.1 所示结构

![图3.1](pic_3.1.png)

Figure 3.1   The App folder and the Grade Scripts section are visible in the Project window. 

图3.1  在项目面板中显示的 App文件夹和Gradle 脚本。

The App folder contains three subfolders that house the files and resources that make up your
application. They are divided so that it should be fairly easy to determine which assets go in
which folder; however, those new to application development or those looking to migrate from
the older Eclipse-based development model might not be certain where files should go. To
make this easier, I walk you through each folder and what it contains. 

在App文件夹中有三个子文件夹，用于存放应用程序中的文件和资源。他们是隔离开的，所以很容易确定相关文件在哪个文件夹中，然而，新手或者从Eclipse转移过来的开发者可能不清楚文件该如何存放，为了使这更容易，我将带你逐一到访每个文件夹，去了解它所包含的内容。

##Manifests(清单文件)
The manifests folder lives up to its name. This is where you would put your manifest files.
Depending on your target, you may have only one manifest file, or you may have several. You
may have several manifest files due to application versioning, or even for supporting specific
hardware. 

清单文件夹没有辜负它的名字， 这里放置你的清单文件，根据你的目标，你可能有一个或多个清单文件，你可能因应用版本，或者支持特定的硬件，使用多个清单文件。

A manifest file is generated by Android Studio when you create a project. Listing 3.1shows a
generated manifest file. 

清单文件是由你创建项目的时候被Android Studio生成的， 列表3.1显示了生成的清单文件。

Listing 3.1 Contents of a Generated Manifest File from Android Studio 

列表3.1 从Android Studio 生成的清单文件

```
   <?xml version="1.0" encoding="utf-8"?>
   <manifest xmlns:android="http://schemas.android.com/apk/res/android"
   package="com.dutsonpa.helloandroid" >
   <application
   android:allowBackup="true"
   android:icon="@drawable/ic_launcher"
   android:label="@string/app_name"
   android:theme="@style/AppTheme" >
   <activity
   android:name=".MainActivity"
   android:label="@string/app_name" >
   <intent-filter>
   <action android:name="android.intent.action.MAIN" />
   <category android:name="android.intent.category.LAUNCHER" />
   </intent-filter>
   </activity>
   </application>
   </manifest> 
```

If you have worked with an Android manifest file before, this file should look familiar. It is
an XML file and as such begins with a declaration of <?xml version="1.0" encoding=
"utf-8"?>. This is done so that the application knows how to handle the information
contained within the file. Because it has been declared as an XML file, you will find that
options and settings inside this file consist of elements that may contain attributes. The next
element after the declaration is a prime example. 

如果你之前用到过Android的清单文件，那么你看到这些应该很熟悉，这是一个以 <?xml version="1.0" encoding= “utf-8”?>声明开始的XML文件，这样做是使得应用程序知道如何处理包含在文件中的信息。因为它被声明为一个XML文件，你会发现文件中的选项和设置是由很多包含属性的元素组成的。在声明之后的下一个元素是一个典型的例子。

The <manifest> element contains some attributes: the XML namespace for Android and the
package name for your application. The package name is the one you created when you started
the project. The <manifest> element can also contain child elements.

在 <manifest> 元素中包含一些属性： Android使用的XML命名空间和应用程序的包名称。
包名称是启动项目的时候创建的。在 <manifest> 元素中同样还可以包含子元素。

In Listing 3.1 , there is only one child element: the <application> element. This contains
more attributes that will affect how your application is displayed as well as if the user is allowed
to have the application be backed up. Other child elements may include any Activities, Intents,
Providers, Receivers, Services, and so on, that the application will need to use.

在清单3.1中，只有一个子元素：<application>元素。它包含更多的属性，它将会影响到应用程序的显示，以及是否允许用户对应用程序进行备份。其他子元素包括应用程序使用到的 Activities, Intents, Providers, Receivers, Services等。

Your manifest may also contain other elements, such as the <uses-permission> element. This
element is both the bane and balm of the application developer. By allowing your application
some access to system functionality, you can create applications that appear to be pure magic,
giving users access to everything they want when they want it. This unfortunately can also
cause some very scary messages to be displayed to the user when they install your application.
A user is much more likely to install your application if you ask for only what you absolutely
need in order to accomplish a task rather than requesting the keys to the kingdom and promising
that you won’t compromise the user or their personal data. 

清单文件中还可以包含其他元素，例如 <uses-permission> 。这个元素对应用开发人员来说是把双刃剑。通过允许应用程序访问一些系统功能，你可以很神奇的创建一个用户想要访问任何事情的应用，不幸的是当他们安装应用程序时，在安装页面会显示一些非常可怕的消息。用户更喜欢去安装请求必要权限达到目的的应用，而不是会危害到用户或者个人数据的应用。

>Note

>You may have previously used <compatible-screens> elements to target specific screen
>sizes for your application. This is no longer an encouraged method of creating applications.
>Instead, you should use different layout resources to allow as many users as possible to enjoy
>and use your application. 

注意
你可能在你的应用程序中已经使用过<compatible-screens>元素来给特定的屏幕尺寸使用。这种做法不再被推荐使用。你应该使用不同的布局资源，让尽可能多的用户享受和使用你的应用程序。

Due to the nature of XML, the order in which you add or remove elements does not matter as
much as the child-parent relationship. However, note that the official documentation lists that
the following elements be ordered as shown in the following pseudo-code: 

由于XML的特质，在其中添加或删除元素的时候顺序并不重要，等同于父子关系。但是，请注意，官方文档列表中显示在下面的伪代码是被排好顺序的：


```
 <manifest>
 <uses-permission />
 <permission />
 <permission-tree />
 <permission-group />
 <instrumentation />
 <uses-sdk />
 <uses-configuration />
 <uses-feature />
 <supports-screens />
 <compatible-screens />
 <supports-gl-texture />
 <application>
 <activity>
 <intent-filter>
 <action />
 <category />
 <data />
 </intent-filter>
 <meta-data />
 </activity>
 <activity-alias>
 <intent-filter></intent-filter>
 <meta-data />
 </activity-alias>
 <service>
 <intent-filter></intent-filter>
 <meta-data/>
 </service>
 <receiver>
 <intent-filter></intent-filter>
 <meta-data />
 </receiver>
 <provider>
 <grant-uri-permission />
 <meta-data />
 <path-permission />
 </provider>
 <uses-library />
 </application>
 </manifest> 
 ```
 
You may be tempted to invent and add your own elements; however, you should know that
the manifest is parsed for a specific set of elements and when custom elements are found it will
cause an error. This is also true when using custom attributes inside of elements.

你可能会想创造并添加自己的元素;但是，你应该知道，清单文件是被解析为特定的元素的集合，当出现自定义的元素会导致错误。同样在元素中使用自定义的属性也会引发错误。

##Java
 
The java folder is self-explanatory. This is the folder in your project where you will be storing
all of the Java files you use to create and work with your application.

java文件夹是不言自明。在这里，你将存储所有项目用到的java文件。

All of your classes will be available here, and Android Studio will even bundle together the
package path so that you can work with the files without having to drill down through the
folders that make up your package.

所有的类都将在这里，Android Studio将会把文件和包路径绑定在一起，这样就可以不用在文件夹下面找来找去了。

You are not limited to keeping your classes inside of the package root. Just like when working
with other Java applications, you are free to create subdirectories that make sense and place
your classes inside of them.

你可以不用非把类文件放在根目录，就像开发其他的java应用一样，你可以自由的创建子目录，然后把类文件放在对应的目录中。

For example, if you were working with database connections and wanted all of your data
classes to reside in an easy-to-use storage location, you could create a “data” folder and place
your classes inside. 

例如，如果你在做数据库连接的工作，并希望所有的数据类驻留在一个易于使用存储的位置，你可以创建一个“Data”文件夹，里面放上你的类。

Depending on how you are creating your application, you may be able to import your classes
for use inside of your MainActivity. If I had created a class for database work named MyDB
and placed it in the “data” folder, I would use the following import to use it inside of my
MainActivity :

根据你创建应用程序的方式，你可以在你的MainActivity中导入Java类使用。如果我创建了一个名为MyDB的数据库相关的类文件，并把它放在“data”文件夹中，我将会使用下面的语句导入到我的MainActivity中：

```
 import com.dutsonpa.HelloAndroid.data.MyDB;
```

When working with your own project, you need to change the domain ( dutsonpa) and application
name ( HelloAndroid) to match.
 
当你使用在自己的项目时，你需要更改域（dutson）和应用程序名称（HelloAndroid）为你的项目中所用到的。

##Res (Resources) (资源)

The manifest and java folders have so far held the essential portions of the application that
allow it to be installed and the logical portion of your application. The “res” folder switches
things up a little bit by controlling the layout, media, and constants that will be used in your
application. The folder is thus named due to it containing all of the resources that your app
relies on. It contains folders that help you separate and sort the resources of your application.

清单文件和java文件夹，已经包含了应用程序的配置和应用程序的逻辑部分。 在“res”文件夹中，通过改变里面的内容，控制在应用中用到的布局，媒体和常量等。因此，该文件夹的名字就是因为包含所有你的应用程序依赖的资源。它包含了帮助你对应用程序的资源进行分离和排序的文件夹。

##Drawable(图片)

The drawable folder contains all the visual media and resources that your application will need
to use. Table 3.1shows drawable types that you can place and use inside of this folder.
 
drawable 文件夹中包含所有的应用中用到的视觉媒体和资源。表3.1列出了 你可以放在drawable下使用的图片类型

Table 3.1 Resource Files for Drawable Folder

表3.1  Drawable文件夹下的资源文件

Drawable Resource | File Type
 --- | ---
Bitmap | Images files (such as .jpg, .png, and .gif).
Bitmap | 图片文件（例如 .jpg, .png, and .gif).
Clip Drawable | An XML file consisting of points that is used in conjunction with another drawable to create a clipped object.
Clip Drawable | 由多个点组成，和另一个drawable结合创建一个裁剪对象的XML文件
Insert Drawable | An XML file that is used to place one drawable inside the bounds of another drawable.
Insert Drawable | 用于在一个drawable中放置另一个drawable的XML文件
Layer List | An XML file that contains an array made up of other drawables. Note that items will be drawn in order based on location in the array placing item [0] on the bottom layer.
Layer List | 包含一组其他的drawable文件的XML文件，注意，drawable集合将会把第一个在最底部按照顺序绘制。
Level List | An XML file that is used to display other drawables that can be accessed based on the level requested through setImageLevel() .
Level List | 一个用于显示一组drawables的XML文件，可以通过setImageLevel()方法设置level来控制显示。
Nine-Patch | A PNG image file that can stretch specific portions to scale based on content size. 
Nine-Patch | 基于内容的大小可伸展特定部分的PNG图像文件。
Scale Drawable | An XML file that contains a drawable that changes the dimension
value of another drawable based on its current value.
Scale Drawable | 一个包含drawable的XML文件，可以根据当前的值改变另一个drawable的尺寸。
Shape Drawable | An XML file that contains the values of geometric shape, color, size, and similar attributes.
Shape Drawable | 包含几何形状，颜色，大小和类似属性值的XML文件。
State List | An XML file that is used for images that have multiple or different states of appearance.
State List | 一个用于显示多个图像或不同状态图像的XML文件。
Transition Drawable | An XML file that contains a drawable that can be transitioned between two items.
Transition Drawable | 包含一个可以在两个条目之间进行转换的drawable的XML文件。

When working with Android Studio, be aware that not all folders may be shown for your
resources. On your file system, you may have separate drawable, drawable-hdpi, drawable-mdpi,
and drawable-xhdpi folders, with each containing a resource that is named the same but that
is to be used specifically for a different display density. In Android Studio this resource will be
shown in the drawable folder as a folder that can be expanded, with the resource it will be used
with in parentheses. Figure 3.2shows how Android Studio displays resources with the same
name in folders that are pixel density dependent. 

当使用Android Studio的时候，要知道，不是所有的文件夹都可以显示你的资源。在你的文件系统中，你可能有分为drawable，drawable-hdpi, drawable-mdpi 和drawable-xhdpi 的文件夹，分别包含同名的资源文件，但是使用在在不同的显示密度上，在Android Studio中 这个资源文件将会被显示在可以展开的 drawable文件夹中，资源文件在括号中标识了使用场景。
图3.2展示了在Android Studio中依赖于像素密度的同名资源是如何显示的。

![图3.2](pic_3.2.png)

Figure 3.2 The ic_launcher.png file is several folders, but is displayed as a single resource
with density-specific versions shown when the main resource is expanded.  

图3.2  ic_launcher.png文件存在于多个文件夹中，但是主资源展开的时候显示为一个带指定密度的单一资源。

##Layout(布局)

The layout folder houses the XML files used for your layouts. The default layout file is named
after your Activity, which if you created a new project in Android Studio and selected the
default settings would be activity_main.xml .

布局文件夹是用于存放布局的XML文件的。默认的布局文件，是根据你的Activity的名字命名，如果你在Android Studio中创建了一个新的项目，并选择了默认设置， 默认的布局文件会是activity_main.xml。

This file is used to set up the layout for your Activity and is used for basic alignment of your
layouts, components, widgets, and similar assets that are used for the UI of your application.

这个文件用于建立你的Activity的布局，也用于其他的布局、组件、widgets（窗体小控件），和asset类似，是为你的应用的UI 服务的。

Similar to the drawables folder, you may have multiple layout folders to handle different
devices. This can be helpful when working with layouts that need to be adjusted for devices
with more or less screen space available. Developers who are used to working with Fragments to
change the layout of the page will be pleased that they can now use a separate layout file that
will automatically be used rather than having to work with a Fragment.

与 drawable文件夹类似，你可能有多个布局文件夹来处理不同的设备，对于拥有更多或更少的屏幕空间的设备，这会很有帮助。
习惯于用 Fragment 来处理页面布局变化的开发者将会很高兴，因为他们可以使用一个分离的layout文件自动处理，而不是不得不使用一个Fragment处理，

To use a separate layout based on screen size, you need to specify the layout based on the dp
unit width or height of the device and place it as the filename. The dp unit stands for density
independent pixel. This unit allows you to use relative measurements that will not be off when
used on devices with different physical pixel resolutions. For example, tablets that are 7" and
larger will generally have a width of 600dp units; this allows you to create a folder named
layout-sw600dp and place your layout XML file there. When the application is opened, it will
check to see which layout should be used and display the layout appropriate for the device.

基于屏幕大小使用一个分离的layout的时候， 你需要基于设备宽高的dp单位指定对应的layout，并且放在对应文件名的文件夹中。
DP单位代表独立密度像素。这个单位允许你使用相对的测量结果，从而在使用不同的像素的时也能正常显示，例如平板是7寸的或者更大，通长宽度有600dp的单位，这让你能创建一个 layout-sw600dp文件夹，放置你的布局文件在这里，当应用运行时，将会检查应该使用哪个Layout 在设备上显示合适的页面。

Layouts can also be supported based on screen density based on dots-per-inch (dpi) by using
folders that are named based on the density, as listed:

布局 也可以被基于dpi(每英寸内包含点数) 的屏幕密度所对应的文件夹来支持，列表如下：

 * ldpi: Used with screens that have ~120dpi.
 	  当屏幕为120dpi的时候使用
 * mdpi: Used with screens that have ~160dpi.
 		当屏幕为160dpi的时候使用
 * hdpi: Used with screens that have ~240dpi.
 		当屏幕为240dpi的时候使用
 * xhdpi: Used with screens that have 320dpi.
 		当屏幕为320dpi的时候使用
 * xxhdpi: Used with screens that have ~480dpi.
 		当屏幕为480dpi的时候使用
 * xxxhdpi: Used with screens that have ~640dpi.
 		当屏幕为640dpi的时候使用
 * nodpi: Resources here will be used on all densities.
 		可以在所有的密度中使用
 * tvdpi: Used on screens sized between mdpi and hdpi, approximately 213dpi.
  	当屏幕大小介于mdpi和hdpi之间，213dpi左右的大小的时候使用
  	
 
##Menu(菜单)

If you opted to create or add a menu to your application, the XML that defines your menu
resides in this folder. You have the option of creating whatever name you would like for your
menu, but if you created a new project in Android Studio and used the default options, you
will find that your menu have been named menu_main.xml .

如果你选择在你的应用中创建或添加一个菜单，定义菜单中的XML存放在此文件夹中。你可以决定创建你的想要的菜单的名字，但是如果你在Android Studio中使用默认配置创建了一个新项目,你会发现，你的菜单被命名menu_main.xml。

This naming convention is actually quite helpful because it identifies what the XML file is for
“menu” and what activity is assigned to “main.” 

这个命名规则其实是很有帮助的，因为它标识了XML文件用于“菜单”的，并且对应activity 是“main”。

##Values

The values folder is used to keep track of the values you will be using in your application. To
create applications with an easier maintenance cycle, it is highly recommended to no longer
hard-code values into your code. Instead, place values in XML files inside of the values folder.

Values文件夹用于记录在应用程序中使用到的值。要创建一个易于维护的应用的时候，强烈建议不要在代码中使用硬编码的值。而是在values文件夹下面的XML文件中存放。

Here’s an example of this:

这是一个示例：

```
// Hard-coding a resource
 <TextView
 android:text="Hello Android!"
 android:layout_width="wrap_content"
 android:layout_height="wrap_content" />
 // Using a value from /res/values/strings.xml
 <TextView
 android:text="@string/hello_android"
 android:layout_width="wrap_content"
 android:layout_height="wrap_content" /> 
```

In the previous example, the value shown in the TextView would change based on the string
entered into strings.xml. The following is an example of a strings.xml file: 

在前面的例子中，在TextView的所显示的值是根据strings.xml中的值进行改变，
下面是一个strings.xml文件的例子：

```
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
 <string name="hello_android">Hello Android!</string>
 </resources> 
```

When you create a new project with Android Studio, the following XML files will be generated
automatically: 

当你创建了Android Studio的一个新项目，下面的XML文件会自动生成：

 * dimens.xml
 * stings.xml
 * styles.xml
 
By looking at these files, you’ll notice that each of them is an XML file with a parent element
of <resources>. This may lead you to think that you could put all of your values in one XML
file and use it inside your application. Although this is something you can do, for the sake of
maintaining your application and knowing exactly where your data is, it is strongly recommended
that you break your values into multiple files. The following list of files may be used in
your application to help keep different values separated: 

通过查看这些文件，你会发现，他们每个都是以<resources>为父元素的XML文件。这可能会让你想到你可以放置所有的value在同一个xml文件中并且在你的应用中使用它。
虽然这样做是可行的，但是为了便于维护你的应用，准确地定位数据所在的位置，我们强烈建议你拆开你的value到多个文件。
下面列表中的文件可以使用在应用程序中，用来存放不同的值：
  
 * arrays.xml
 * colors.xml
 * dimens.xml
 * strings.xml
 * styles.xml
 
Each file is clearly named so that you know exactly what you are dealing with. Also, each file is
named after the element that would be placed in a parent <resource> element. For example,
color values would reside in a <color> element that is a child of the <resource> element. 

每个文件被清楚地命名，这样你会确切地知道你正在处理什么数据。此外，每个文件的元素都是在父元素<resource>之内。例如，颜色值将放在<Resource>元素的子元素<color>中。

##Other Resources(其他资源)

You can create other folders for other resources in your application. Table 3.2lists each folder
name as well as what should be stored in that folder.

你可以在应用中创建的其他资源对应的文件夹。
表3.2列出了每个文件夹的名称，以及应该存放什么资源。

Table 3.2 Application Resource Folders 

表3.2 应用资源文件夹

Folder Name | Folder Contents
 --- | ---
animator | XML files for property animations
animator | 属性动画的XML文件
anim | XML files for tween animations
anim | 补间动画的XML文件 
color | XML files for color state lists
color | 存放颜色状态集合的XML文件
raw | Stores files that will be read with an AssetManager
raw | 存放能被AssetManager读取的文件
xml | Any XML files that you will be using in your application with the
Resources.getXML() method 
xml | 在应用中被Resources.getXML()用到的任何XML文件

>Tip
>You may be wondering where to place audio files that your application uses. You can store
>them in /res/raw and access them with R.raw.audio_file. This eliminates the need for
>any other project-level folders and keeps your res folder organized. 

>提醒
>你可能想知道在什么地方存放应用程序使用的音频文件。你可以将它们放置在 /res/raw，并通过R.raw.audio_file访问它们。免于使用其他的项目文件夹，这样做保持了资源文件夹是条理清晰的。


##Gradle

With Android Studio, the decision was made to leave ant for project building and move to
Gradle. To help you manage your build files, Android Studio adds a section named Gradle
Scripts to your project. When expanded, Gradle Scripts will show you your build configuration
file, properties, and setting files.

在使用Android Studio的同时，构建项目的任务从Ant迁移到了Gradle。为了帮助你管理你的构建文件，Android Studio添加一个名为Gradle的脚本在你的项目中。展开Gradle脚本文件,你会看到你的构建配置文件，属性和设置文件。

When you are migrating a project created with Android Studio, you may find that you need to
adjust some of these settings to match newer versions of Gradle or of the build tools used. You
can see the current settings by viewing the build.gradle file in your app folder. Listing 3.2
shows a sample build file. 

当你的要迁移一个Android Studio创建的项目的时候，你也许会发现你需要调整一些配置去匹配新的Gradle版本或者使用到的构建工具。你可以通过查看 app文件夹里的build.grade 了解当前的配置，列表3.2显示了一个构建文件的示例。

Listing 3.2 A build.gradle File for an Android Application

列表3.2 一个Android应用的build.gradle文件

```
apply plugin: 'com.android.application'
 android {
 compileSdkVersion 21
 buildToolsVersion "21.1.2"
 defaultConfig {
 applicationId "com.dutsonpa.helloandroid"
 minSdkVersion 15
 targetSdkVersion 21
 versionCode 1
 versionName "1.0"
 }
 buildTypes {
 release {
 minifyEnabled false
 proguardFiles getDefaultProguardFile('proguard-android.txt'),
 'proguard-rules.pro'
 }
 }
 }
 dependencies {
 compile fileTree(dir: 'libs', include: ['*.jar'])
 compile 'com.android.support:appcompat-v7:21.0.3'
 } 
```

When you’re migrating or upgrading your application, the lines you need to pay the most
attention to are the compileSdkVersion, buildToolsVersion, minSdkVersion, and
targetSdkVersion. If these numbers do not match what you have installed on your system,
you will see compilation errors and your application will fail to launch on an emulator or
device, or even compile.

当你迁移或升级应用，需要重点关注的是compileSdkVersion，buildToolsVersion，minSdkVersion和targetSdkVersion。如果这些数字和你的应用要安装的系统不匹配，你将会看到编译错误，你的应用程序将无法在模拟器或设备上运行甚至编译。

The other Gradle files should be managed by Android Studio and will be updated as need when
your project is built and compiled. If you want to learn more about Gradle, visit the official
website: https://gradle.org/ . 

其他的 Gradle 文件在你的项目构建和编译完成的时候，是由Android Studio进行管理和更新的。
如果你想了解更多关于 Gradle，请访问官方网站：https://gradle.org/。

##Summary(概要)

In this chapter, you learned about the components that make up an Android application. You
learned that with the change from Eclipse with the ADT plugin to Android Studio as the development
IDE, the project structure and application assets are stored in different locations.
You learned about the application manifest and the various elements that can be included,
such as the security elements that allow your application to access system resources to further
extend the functionality of your application. 

在本章中，你学习到了构成Android应用的组件、作为开发集成环境从Eclipse的ADT插件到Android Studio的变化、项目结构和存储在不同位置的应用资产，还有关于应用的清单文件和里面包含的元素，例如权限元素允许应用能访问系统的资源，进一步扩展应用程序的功能。

You also learned that you can use folders that contain assets for specific devices based on the
device screen density. This allows you to create specific layouts for multiple devices without
having to resort to using Fragments for layout changes.

你也了解到了，你可以使用基于设备屏幕密度的文件夹存放指定设备的资产。
这可以让你创建特定的布局给多种设备使用，而不用求助于Fragment来处理布局的变化。

Finally, you learned that Android Studio uses the Gradle build system and that some problems
can be avoided by making sure that it has been configured for your environment.
 
最后，学习到了Android Studio中使用的 Gradle 构建系统，通过对环境的配置可以避免一些问题。





