#Application Structure
#应用结构


With the decision to change the supported development platform from the ADT bundle to Android Studio also came the decision to start using Gradle as the build system. This opened the door for many developers to start assembling Android applications in a more collaborative way and changed the file structure with which prior projects were built.

当开发环境从ADT bundle转向Android Studio的同时，Gradle开始作为编译系统。这让开发者有了很多协作的方式去开发Android应用，并且改变了编译文件的结构。

In this chapter, you learn the new file system structure as well as the types of files you can
include in your project, including where XML files are located, where image assets are stored,
and where the Gradle build files are stored. 

在本章中，你将会学到新的文件系统结构以及项目中使用到的文件类型，包括XML文件,图片资源,还有Gradle编译文件的存放位置。

When you create an application in Android Studio, you find that the project is divided into an
App folder and Gradle scripts. 

Figure 3.1shows this structure. 

当你在Android Studio中创建应用程序时，你会发现项目分为App文件夹和Gradle脚本文件。

图3.1 所示结构

![图3.1 所示结构](pic_3.2.png)

Figure 3.1   The App folder and the Grade Scripts section are visible in the Project window. 

图3.1  在项目面板中显示的 App文件夹和Gradle 脚本。

The App folder contains three subfolders that house the files and resources that make up your
application. They are divided so that it should be fairly easy to determine which assets go in
which folder; however, those new to application development or those looking to migrate from
the older Eclipse-based development model might not be certain where files should go. To
make this easier, I walk you through each folder and what it contains. 

在App文件夹中有三个子文件夹，用于存放应用程序中的文件和资源。他们是隔离开的，所以很容易确定相关文件在哪个文件夹中，然而，新手或者从Eclipse转移过来的开发者可能不清楚文件该如何存放，为了使这更容易，我将带你逐一到访每个文件夹，去了解它所包含的内容。

##Manifests(清单文件)
The manifests folder lives up to its name. This is where you would put your manifest files.
Depending on your target, you may have only one manifest file, or you may have several. You
may have several manifest files due to application versioning, or even for supporting specific
hardware. 

清单文件夹没有辜负它的名字， 这里放置你的清单文件，根据你的目标，你可能有一个或多个清单文件，你可能因应用版本，或者支持特定的硬件，使用多个清单文件。

A manifest file is generated by Android Studio when you create a project. Listing 3.1shows a
generated manifest file. 

清单文件是由你创建项目的时候被Android Studio生成的， 列表3.1显示了生成的清单文件。

Listing 3.1 Contents of a Generated Manifest File from Android Studio 

列表3.1 从Android Studio 生成的清单文件

```
   <?xml version="1.0" encoding="utf-8"?>
   <manifest xmlns:android="http://schemas.android.com/apk/res/android"
   package="com.dutsonpa.helloandroid" >
   <application
   android:allowBackup="true"
   android:icon="@drawable/ic_launcher"
   android:label="@string/app_name"
   android:theme="@style/AppTheme" >
   <activity
   android:name=".MainActivity"
   android:label="@string/app_name" >
   <intent-filter>
   <action android:name="android.intent.action.MAIN" />
   <category android:name="android.intent.category.LAUNCHER" />
   </intent-filter>
   </activity>
   </application>
   </manifest> 
```

If you have worked with an Android manifest file before, this file should look familiar. It is
an XML file and as such begins with a declaration of <?xml version="1.0" encoding=
"utf-8"?>. This is done so that the application knows how to handle the information
contained within the file. Because it has been declared as an XML file, you will find that
options and settings inside this file consist of elements that may contain attributes. The next
element after the declaration is a prime example. 

如果你之前用到过Android的清单文件，那么你看到这些应该很熟悉，这是一个以 <?xml version="1.0" encoding= “utf-8”?>声明开始的XML文件，这样做是使得应用程序知道如何处理包含在文件中的信息。因为它被声明为一个XML文件，你会发现文件中的选项和设置是由很多包含属性的元素组成的。在声明之后的下一个元素是一个典型的例子。

The <manifest> element contains some attributes: the XML namespace for Android and the
package name for your application. The package name is the one you created when you started
the project. The <manifest> element can also contain child elements.

在 <manifest> 元素中包含一些属性： Android使用的XML命名空间和应用程序的包名称。
包名称是启动项目的时候创建的。在 <manifest> 元素中同样还可以包含子元素。

In Listing 3.1 , there is only one child element: the <application> element. This contains
more attributes that will affect how your application is displayed as well as if the user is allowed
to have the application be backed up. Other child elements may include any Activities, Intents,
Providers, Receivers, Services, and so on, that the application will need to use.

在清单3.1中，只有一个子元素：<application>元素。它包含更多的属性，它将会影响到应用程序的显示，以及是否允许用户对应用程序进行备份。其他子元素包括应用程序使用到的 Activities, Intents, Providers, Receivers, Services等。

Your manifest may also contain other elements, such as the <uses-permission> element. This
element is both the bane and balm of the application developer. By allowing your application
some access to system functionality, you can create applications that appear to be pure magic,
giving users access to everything they want when they want it. This unfortunately can also
cause some very scary messages to be displayed to the user when they install your application.
A user is much more likely to install your application if you ask for only what you absolutely
need in order to accomplish a task rather than requesting the keys to the kingdom and promising
that you won’t compromise the user or their personal data. 

清单文件中还可以包含其他元素，例如 <uses-permission> 。这个元素对应用开发人员来说是把双刃剑。通过允许应用程序访问一些系统功能，你可以很神奇的创建一个用户想要访问任何事情的应用，不幸的是当他们安装应用程序时，在安装页面会显示一些非常可怕的消息。用户更喜欢去安装请求必要权限达到目的的应用，而不是会危害到用户或者个人数据的应用。

```
 Note
You may have previously used <compatible-screens> elements to target specific screen
sizes for your application. This is no longer an encouraged method of creating applications.
Instead, you should use different layout resources to allow as many users as possible to enjoy
and use your application. 
```

注意
你可能在你的应用程序中已经使用过<compatible-screens>元素来给特定的屏幕尺寸使用。这种做法不再被推荐使用。你应该使用不同的布局资源，让尽可能多的用户享受和使用你的应用程序。

Due to the nature of XML, the order in which you add or remove elements does not matter as
much as the child-parent relationship. However, note that the official documentation lists that
the following elements be ordered as shown in the following pseudo-code: 

由于XML的特质，在其中添加或删除元素的时候顺序并不重要，等同于父子关系。但是，请注意，官方文档列表中显示在下面的伪代码是被排好顺序的：


```
 <manifest>
 <uses-permission />
 <permission />
 <permission-tree />
 <permission-group />
 <instrumentation />
 <uses-sdk />
 <uses-configuration />
 <uses-feature />
 <supports-screens />
 <compatible-screens />
 <supports-gl-texture />
 <application>
 <activity>
 <intent-filter>
 <action />
 <category />
 <data />
 </intent-filter>
 <meta-data />
 </activity>
 <activity-alias>
 <intent-filter></intent-filter>
 <meta-data />
 </activity-alias>
 <service>
 <intent-filter></intent-filter>
 <meta-data/>
 </service>
 <receiver>
 <intent-filter></intent-filter>
 <meta-data />
 </receiver>
 <provider>
 <grant-uri-permission />
 <meta-data />
 <path-permission />
 </provider>
 <uses-library />
 </application>
 </manifest> 
 ```
 
You may be tempted to invent and add your own elements; however, you should know that
the manifest is parsed for a specific set of elements and when custom elements are found it will
cause an error. This is also true when using custom attributes inside of elements.
 Java
The java folder is self-explanatory. This is the folder in your project where you will be storing
all of the Java files you use to create and work with your application.
All of your classes will be available here, and Android Studio will even bundle together the
package path so that you can work with the files without having to drill down through the
folders that make up your package.
You are not limited to keeping your classes inside of the package root. Just like when working
with other Java applications, you are free to create subdirectories that make sense and place
your classes inside of them.
For example, if you were working with database connections and wanted all of your data
classes to reside in an easy-to-use storage location, you could create a “data” folder and place
your classes inside. 

